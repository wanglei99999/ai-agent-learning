# å·¥å…·ç³»ç»Ÿè¯¦è§£ (`tools/`)

> æ·±å…¥ç†è§£ HelloAgents çš„å·¥å…·è®¾è®¡ä¸å®ç°æœºåˆ¶

---

## ğŸ“š ç›®å½•

- [æ¨¡å—æ¦‚è¿°](#æ¨¡å—æ¦‚è¿°)
- [Tool åŸºç±»è¯¦è§£](#tool-åŸºç±»è¯¦è§£)
- [å·¥å…·æ³¨å†Œè¡¨è¯¦è§£](#å·¥å…·æ³¨å†Œè¡¨è¯¦è§£)
- [è£…é¥°å™¨æ¨¡å¼](#è£…é¥°å™¨æ¨¡å¼)
- [è‡ªåŠ¨å‚æ•°è§£æ](#è‡ªåŠ¨å‚æ•°è§£æ)
- [å·¥å…·é“¾è¯¦è§£](#å·¥å…·é“¾è¯¦è§£)
- [å¼‚æ­¥æ‰§è¡Œå™¨è¯¦è§£](#å¼‚æ­¥æ‰§è¡Œå™¨è¯¦è§£)
- [å®æˆ˜ç¤ºä¾‹](#å®æˆ˜ç¤ºä¾‹)

---

## æ¨¡å—æ¦‚è¿°

### æ–‡ä»¶ç»“æ„
```
tools/
â”œâ”€â”€ base.py          # å·¥å…·åŸºç±»å’Œè£…é¥°å™¨
â”œâ”€â”€ registry.py      # å·¥å…·æ³¨å†Œè¡¨
â”œâ”€â”€ chain.py         # å·¥å…·é“¾ç¼–æ’
â””â”€â”€ async_executor.py # å¼‚æ­¥æ‰§è¡Œå™¨
```

### æ ¸å¿ƒè®¾è®¡ç†å¿µ

**1. å·¥å…·å³å‡½æ•°**
- æ¯ä¸ªå·¥å…·å°è£…ä¸€ä¸ªç‰¹å®šåŠŸèƒ½
- ç»Ÿä¸€çš„è¾“å…¥è¾“å‡ºæ¥å£
- å¯ç»„åˆã€å¯å¤ç”¨

**2. ä¸¤ç§ä½¿ç”¨æ¨¡å¼**
```python
# æ¨¡å¼1: æ™®é€šå·¥å…·ï¼ˆå•ä¸€åŠŸèƒ½ï¼‰
class SearchTool(Tool):
    def run(self, parameters):
        return search(parameters['query'])

# æ¨¡å¼2: å¯å±•å¼€å·¥å…·ï¼ˆå¤šä¸ªåŠŸèƒ½ï¼‰
class MemoryTool(Tool):
    expandable = True
    
    @tool_action("add", "æ·»åŠ è®°å¿†")
    def _add(self, content: str):
        return self.memory.add(content)
    
    @tool_action("search", "æœç´¢è®°å¿†")
    def _search(self, query: str):
        return self.memory.search(query)
```

---

## Tool åŸºç±»è¯¦è§£

### å®Œæ•´ä»£ç ç»“æ„

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

class Tool(ABC):
    """å·¥å…·åŸºç±»"""
    
    def __init__(self, name: str, description: str, expandable: bool = False):
        self.name = name
        self.description = description
        self.expandable = expandable
    
    @abstractmethod
    def run(self, parameters: Dict[str, Any]) -> str:
        """æ‰§è¡Œå·¥å…·"""
        pass
    
    @abstractmethod
    def get_parameters(self) -> List[ToolParameter]:
        """è·å–å·¥å…·å‚æ•°å®šä¹‰"""
        pass
    
    def get_expanded_tools(self) -> Optional[List['Tool']]:
        """è·å–å±•å¼€åçš„å­å·¥å…·åˆ—è¡¨"""
        pass
```

### æ ¸å¿ƒå±æ€§

#### 1. name (å·¥å…·åç§°)

```python
self.name = name  # å¿…å¡«
```

**ç”¨é€”**ï¼š
- å”¯ä¸€æ ‡è¯†å·¥å…·
- Agent è°ƒç”¨æ—¶ä½¿ç”¨
- æ—¥å¿—å’Œè°ƒè¯•

**å‘½åè§„èŒƒ**ï¼š
```python
# âœ… å¥½çš„å‘½å
"web_search"       # æ¸…æ™°ã€æè¿°æ€§
"calculator_add"   # åŠŸèƒ½æ˜ç¡®
"file_read"        # åŠ¨è¯+åè¯

# âŒ ä¸å¥½çš„å‘½å
"tool1"            # æ— æ„ä¹‰
"search"           # å¤ªå®½æ³›
"doSomething"      # ä¸æ¸…æ™°
```

#### 2. description (å·¥å…·æè¿°)

```python
self.description = description  # å¿…å¡«
```

**ç”¨é€”**ï¼š
- å‘Šè¯‰ LLM å·¥å…·çš„åŠŸèƒ½
- å¸®åŠ© LLM é€‰æ‹©åˆé€‚çš„å·¥å…·
- ç”Ÿæˆå·¥å…·æ–‡æ¡£

**æè¿°è§„èŒƒ**ï¼š
```python
# âœ… å¥½çš„æè¿°
description = "åœ¨ç½‘ç»œä¸Šæœç´¢ä¿¡æ¯ï¼Œè¿”å›ç›¸å…³çš„æœç´¢ç»“æœæ‘˜è¦"

# âœ… æ›´è¯¦ç»†çš„æè¿°
description = """æœç´¢å·¥å…·ï¼šåœ¨äº’è”ç½‘ä¸Šæœç´¢ä¿¡æ¯
è¾“å…¥ï¼šæœç´¢å…³é”®è¯
è¾“å‡ºï¼šæœç´¢ç»“æœæ‘˜è¦ï¼ˆåŒ…å«æ ‡é¢˜ã€é“¾æ¥ã€ç®€ä»‹ï¼‰
é€‚ç”¨åœºæ™¯ï¼šéœ€è¦è·å–æœ€æ–°ä¿¡æ¯ã€æŸ¥æ‰¾èµ„æ–™æ—¶ä½¿ç”¨"""

# âŒ ä¸å¥½çš„æè¿°
description = "æœç´¢"  # å¤ªç®€å•
description = "è¿™æ˜¯ä¸€ä¸ªå·¥å…·"  # æ— æ„ä¹‰
```

#### 3. expandable (æ˜¯å¦å¯å±•å¼€)

```python
self.expandable = expandable  # é»˜è®¤ False
```

**ç”¨é€”**ï¼š
- æ ‡è®°å·¥å…·æ˜¯å¦åŒ…å«å¤šä¸ªå­åŠŸèƒ½
- æ§åˆ¶æ˜¯å¦è‡ªåŠ¨å±•å¼€ä¸ºå¤šä¸ªç‹¬ç«‹å·¥å…·

**ä½¿ç”¨åœºæ™¯**ï¼š
```python
# åœºæ™¯1: å•ä¸€åŠŸèƒ½å·¥å…·
class SearchTool(Tool):
    def __init__(self):
        super().__init__(
            name="search",
            description="æœç´¢å·¥å…·",
            expandable=False  # ä¸å¯å±•å¼€
        )

# åœºæ™¯2: å¤šåŠŸèƒ½å·¥å…·
class MemoryTool(Tool):
    def __init__(self):
        super().__init__(
            name="memory",
            description="è®°å¿†ç®¡ç†å·¥å…·",
            expandable=True  # å¯å±•å¼€
        )
    
    @tool_action("add", "æ·»åŠ è®°å¿†")
    def _add(self, content: str):
        pass
    
    @tool_action("search", "æœç´¢è®°å¿†")
    def _search(self, query: str):
        pass
```

### æ ¸å¿ƒæ–¹æ³•

#### 1. run() - æ‰§è¡Œå·¥å…· â­

```python
@abstractmethod
def run(self, parameters: Dict[str, Any]) -> str:
    """æ‰§è¡Œå·¥å…·"""
    pass
```

**å‚æ•°æ ¼å¼**ï¼š
```python
parameters = {
    "query": "Python æ•™ç¨‹",
    "limit": 10,
    "language": "zh"
}
```

**è¿”å›å€¼**ï¼š
- å¿…é¡»è¿”å›å­—ç¬¦ä¸²
- åŒ…å«å·¥å…·æ‰§è¡Œç»“æœ
- å¦‚æœå¤±è´¥ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯

**å®ç°ç¤ºä¾‹**ï¼š
```python
class SearchTool(Tool):
    def run(self, parameters: Dict[str, Any]) -> str:
        query = parameters.get('query', '')
        limit = parameters.get('limit', 5)
        
        try:
            results = self._search(query, limit)
            return f"æ‰¾åˆ° {len(results)} æ¡ç»“æœï¼š\n" + "\n".join(results)
        except Exception as e:
            return f"æœç´¢å¤±è´¥: {str(e)}"
```

#### 2. get_parameters() - è·å–å‚æ•°å®šä¹‰

```python
@abstractmethod
def get_parameters(self) -> List[ToolParameter]:
    """è·å–å·¥å…·å‚æ•°å®šä¹‰"""
    pass
```

**ToolParameter ç»“æ„**ï¼š
```python
class ToolParameter(BaseModel):
    name: str           # å‚æ•°å
    type: str           # ç±»å‹: string/integer/number/boolean/array/object
    description: str    # å‚æ•°æè¿°
    required: bool      # æ˜¯å¦å¿…éœ€
    default: Any        # é»˜è®¤å€¼
```

**å®ç°ç¤ºä¾‹**ï¼š
```python
class SearchTool(Tool):
    def get_parameters(self) -> List[ToolParameter]:
        return [
            ToolParameter(
                name="query",
                type="string",
                description="æœç´¢å…³é”®è¯",
                required=True
            ),
            ToolParameter(
                name="limit",
                type="integer",
                description="è¿”å›ç»“æœæ•°é‡",
                required=False,
                default=5
            )
        ]
```

#### 3. get_expanded_tools() - è·å–å­å·¥å…·

```python
def get_expanded_tools(self) -> Optional[List['Tool']]:
    """è·å–å±•å¼€åçš„å­å·¥å…·åˆ—è¡¨"""
    if not self.expandable:
        return None
    
    # è‡ªåŠ¨ä» @tool_action è£…é¥°çš„æ–¹æ³•ç”Ÿæˆå·¥å…·
    tools = []
    for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
        if hasattr(method, '_is_tool_action'):
            tool = AutoGeneratedTool(
                parent=self,
                method=method,
                name=method._tool_name,
                description=method._tool_description
            )
            tools.append(tool)
    
    return tools if tools else None
```

**å·¥ä½œæµç¨‹**ï¼š

```mermaid
graph TD
    A[æ£€æŸ¥ expandable] --> B{æ˜¯å¦å¯å±•å¼€?}
    B -->|å¦| C[è¿”å› None]
    B -->|æ˜¯| D[æ‰«ææ‰€æœ‰æ–¹æ³•]
    D --> E{æœ‰ @tool_action?}
    E -->|æ˜¯| F[åˆ›å»º AutoGeneratedTool]
    E -->|å¦| G[è·³è¿‡]
    F --> H[æ·»åŠ åˆ°åˆ—è¡¨]
    G --> D
    H --> I[è¿”å›å·¥å…·åˆ—è¡¨]
```

### è¾…åŠ©æ–¹æ³•

#### validate_parameters() - éªŒè¯å‚æ•°

```python
def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
    """éªŒè¯å‚æ•°æ˜¯å¦æ»¡è¶³è¦æ±‚"""
    required_params = [p.name for p in self.get_parameters() if p.required]
    return all(param in parameters for param in required_params)
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
tool = SearchTool()
params = {"query": "Python"}

if tool.validate_parameters(params):
    result = tool.run(params)
else:
    print("ç¼ºå°‘å¿…éœ€å‚æ•°")
```

#### to_openai_schema() - è½¬æ¢ä¸º OpenAI æ ¼å¼

```python
def to_openai_schema(self) -> Dict[str, Any]:
    """è½¬æ¢ä¸º OpenAI function calling schema æ ¼å¼"""
    parameters = self.get_parameters()
    
    properties = {}
    required = []
    
    for param in parameters:
        properties[param.name] = {
            "type": param.type,
            "description": param.description
        }
        if param.required:
            required.append(param.name)
    
    return {
        "type": "function",
        "function": {
            "name": self.name,
            "description": self.description,
            "parameters": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }
    }
```

**ç”¨é€”**ï¼š
- æ”¯æŒ OpenAI åŸç”Ÿ Function Calling
- ç”¨äº FunctionCallAgent

**è¾“å‡ºç¤ºä¾‹**ï¼š
```json
{
  "type": "function",
  "function": {
    "name": "search",
    "description": "æœç´¢å·¥å…·",
    "parameters": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "æœç´¢å…³é”®è¯"
        },
        "limit": {
          "type": "integer",
          "description": "è¿”å›ç»“æœæ•°é‡"
        }
      },
      "required": ["query"]
    }
  }
}
```

---

## å·¥å…·æ³¨å†Œè¡¨è¯¦è§£

### ToolRegistry ç±»

```python
class ToolRegistry:
    """å·¥å…·æ³¨å†Œè¡¨ - ç®¡ç†æ‰€æœ‰å·¥å…·"""
    
    def __init__(self):
        self._tools: dict[str, Tool] = {}           # Tool å¯¹è±¡
        self._functions: dict[str, dict] = {}       # å‡½æ•°å·¥å…·
```

### ä¸¤ç§æ³¨å†Œæ–¹å¼

#### æ–¹å¼1: æ³¨å†Œ Tool å¯¹è±¡ï¼ˆæ¨èï¼‰

```python
def register_tool(self, tool: Tool, auto_expand: bool = True):
    """æ³¨å†Œ Tool å¯¹è±¡"""
    
    # æ£€æŸ¥æ˜¯å¦å¯å±•å¼€
    if auto_expand and tool.expandable:
        expanded_tools = tool.get_expanded_tools()
        if expanded_tools:
            # æ³¨å†Œæ‰€æœ‰å­å·¥å…·
            for sub_tool in expanded_tools:
                self._tools[sub_tool.name] = sub_tool
            return
    
    # æ³¨å†Œæ™®é€šå·¥å…·
    self._tools[tool.name] = tool
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
registry = ToolRegistry()

# æ³¨å†Œæ™®é€šå·¥å…·
search_tool = SearchTool()
registry.register_tool(search_tool)

# æ³¨å†Œå¯å±•å¼€å·¥å…·ï¼ˆè‡ªåŠ¨å±•å¼€ï¼‰
memory_tool = MemoryTool()  # åŒ…å« addã€search ç­‰æ–¹æ³•
registry.register_tool(memory_tool)
# ç»“æœï¼šæ³¨å†Œäº† memory_addã€memory_search ç­‰å¤šä¸ªå·¥å…·
```

#### æ–¹å¼2: æ³¨å†Œå‡½æ•°ï¼ˆç®€ä¾¿ï¼‰

```python
def register_function(self, name: str, description: str, func: Callable[[str], str]):
    """ç›´æ¥æ³¨å†Œå‡½æ•°ä½œä¸ºå·¥å…·"""
    self._functions[name] = {
        "description": description,
        "func": func
    }
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```python
def my_search(query: str) -> str:
    return f"æœç´¢ç»“æœ: {query}"

registry.register_function(
    name="search",
    description="æœç´¢å·¥å…·",
    func=my_search
)
```

**ä¸¤ç§æ–¹å¼å¯¹æ¯”**ï¼š

| ç‰¹æ€§ | Tool å¯¹è±¡ | å‡½æ•°æ³¨å†Œ |
|------|----------|---------|
| å‚æ•°å®šä¹‰ | âœ… æ”¯æŒå¤æ‚å‚æ•° | âŒ åªæ”¯æŒå­—ç¬¦ä¸² |
| ç±»å‹è½¬æ¢ | âœ… è‡ªåŠ¨è½¬æ¢ | âŒ éœ€æ‰‹åŠ¨å¤„ç† |
| å‚æ•°éªŒè¯ | âœ… è‡ªåŠ¨éªŒè¯ | âŒ æ— éªŒè¯ |
| OpenAI æ ¼å¼ | âœ… æ”¯æŒ | âŒ ä¸æ”¯æŒ |
| ä½¿ç”¨éš¾åº¦ | ä¸­ç­‰ | ç®€å• |
| æ¨èåœºæ™¯ | å¤æ‚å·¥å…· | ç®€å•å·¥å…· |

### æ ¸å¿ƒæ–¹æ³•

#### execute_tool() - æ‰§è¡Œå·¥å…·

```python
def execute_tool(self, name: str, input_text: str) -> str:
    """æ‰§è¡ŒæŒ‡å®šå·¥å…·"""
    
    # ä¼˜å…ˆæŸ¥æ‰¾ Tool å¯¹è±¡
    if name in self._tools:
        tool = self._tools[name]
        try:
            return tool.run({"input": input_text})
        except Exception as e:
            return f"é”™è¯¯ï¼š{str(e)}"
    
    # æŸ¥æ‰¾å‡½æ•°å·¥å…·
    elif name in self._functions:
        func = self._functions[name]["func"]
        try:
            return func(input_text)
        except Exception as e:
            return f"é”™è¯¯ï¼š{str(e)}"
    
    else:
        return f"é”™è¯¯ï¼šæœªæ‰¾åˆ°å·¥å…· '{name}'"
```

**æ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph TD
    A[execute_tool] --> B{Tool å¯¹è±¡å­˜åœ¨?}
    B -->|æ˜¯| C[è°ƒç”¨ tool.run]
    B -->|å¦| D{å‡½æ•°å·¥å…·å­˜åœ¨?}
    D -->|æ˜¯| E[è°ƒç”¨å‡½æ•°]
    D -->|å¦| F[è¿”å›é”™è¯¯]
    C --> G{æ‰§è¡ŒæˆåŠŸ?}
    E --> G
    G -->|æ˜¯| H[è¿”å›ç»“æœ]
    G -->|å¦| I[è¿”å›é”™è¯¯ä¿¡æ¯]
```

#### get_tools_description() - è·å–å·¥å…·æè¿°

```python
def get_tools_description(self) -> str:
    """è·å–æ‰€æœ‰å·¥å…·çš„æè¿°"""
    descriptions = []
    
    # Tool å¯¹è±¡
    for tool in self._tools.values():
        descriptions.append(f"- {tool.name}: {tool.description}")
    
    # å‡½æ•°å·¥å…·
    for name, info in self._functions.items():
        descriptions.append(f"- {name}: {info['description']}")
    
    return "\n".join(descriptions) if descriptions else "æš‚æ— å¯ç”¨å·¥å…·"
```

**è¾“å‡ºç¤ºä¾‹**ï¼š
```
- search: åœ¨ç½‘ç»œä¸Šæœç´¢ä¿¡æ¯
- calculator: æ‰§è¡Œæ•°å­¦è®¡ç®—
- file_read: è¯»å–æ–‡ä»¶å†…å®¹
- memory_add: æ·»åŠ æ–°è®°å¿†
- memory_search: æœç´¢è®°å¿†
```

**ç”¨é€”**ï¼š
- æ„å»º Agent çš„ system prompt
- è®© LLM çŸ¥é“æœ‰å“ªäº›å·¥å…·å¯ç”¨

---

## è£…é¥°å™¨æ¨¡å¼

### @tool_action è£…é¥°å™¨

```python
def tool_action(name: str = None, description: str = None):
    """æ ‡è®°æ–¹æ³•ä¸ºå¯å±•å¼€çš„å·¥å…· action"""
    def decorator(func: Callable):
        func._is_tool_action = True
        func._tool_name = name
        func._tool_description = description
        return func
    return decorator
```

### ä½¿ç”¨ç¤ºä¾‹

```python
class MemoryTool(Tool):
    def __init__(self):
        super().__init__(
            name="memory",
            description="è®°å¿†ç®¡ç†å·¥å…·",
            expandable=True  # å…³é”®ï¼šæ ‡è®°ä¸ºå¯å±•å¼€
        )
        self.memories = []
    
    @tool_action("add", "æ·»åŠ æ–°è®°å¿†")
    def _add_memory(self, content: str, importance: float = 0.5) -> str:
        """æ·»åŠ è®°å¿†
        
        Args:
            content: è®°å¿†å†…å®¹
            importance: é‡è¦æ€§åˆ†æ•° (0-1)
        """
        self.memories.append({
            "content": content,
            "importance": importance
        })
        return f"å·²æ·»åŠ è®°å¿†: {content}"
    
    @tool_action("search", "æœç´¢è®°å¿†")
    def _search_memory(self, query: str, limit: int = 5) -> str:
        """æœç´¢è®°å¿†
        
        Args:
            query: æœç´¢å…³é”®è¯
            limit: è¿”å›æ•°é‡
        """
        results = [m for m in self.memories if query in m["content"]]
        return f"æ‰¾åˆ° {len(results)} æ¡è®°å¿†"
    
    @tool_action("delete", "åˆ é™¤è®°å¿†")
    def _delete_memory(self, index: int) -> str:
        """åˆ é™¤è®°å¿†
        
        Args:
            index: è®°å¿†ç´¢å¼•
        """
        if 0 <= index < len(self.memories):
            deleted = self.memories.pop(index)
            return f"å·²åˆ é™¤: {deleted['content']}"
        return "ç´¢å¼•æ— æ•ˆ"
```

### è‡ªåŠ¨å±•å¼€è¿‡ç¨‹

```mermaid
graph TD
    A[MemoryTool] --> B[register_tool]
    B --> C{expandable=True?}
    C -->|æ˜¯| D[get_expanded_tools]
    D --> E[æ‰«ææ‰€æœ‰æ–¹æ³•]
    E --> F[æ‰¾åˆ° @tool_action]
    F --> G[åˆ›å»º AutoGeneratedTool]
    G --> H[memory_add]
    G --> I[memory_search]
    G --> J[memory_delete]
    H --> K[æ³¨å†Œåˆ° registry]
    I --> K
    J --> K
```

**ç»“æœ**ï¼š
```python
# æ³¨å†Œå‰ï¼š1 ä¸ªå·¥å…·
memory_tool = MemoryTool()

# æ³¨å†Œåï¼š3 ä¸ªç‹¬ç«‹å·¥å…·
registry.register_tool(memory_tool)
# - memory_add
# - memory_search
# - memory_delete
```

---

## è‡ªåŠ¨å‚æ•°è§£æ

### AutoGeneratedTool ç±»

```python
class AutoGeneratedTool(Tool):
    """ä»æ–¹æ³•è‡ªåŠ¨ç”Ÿæˆçš„å·¥å…·"""
    
    def __init__(self, parent: Tool, method: Callable, name: str, description: str):
        self.parent = parent
        self.method = method
        super().__init__(name=name, description=description)
        self._parameters = self._parse_parameters()
```

### å‚æ•°è§£ææµç¨‹

#### 1. ä»æ–¹æ³•ç­¾åæå–å‚æ•°

```python
def _parse_parameters(self) -> List[ToolParameter]:
    """ä»æ–¹æ³•ç­¾åè‡ªåŠ¨æå–å‚æ•°"""
    sig = inspect.signature(self.method)
    type_hints = get_type_hints(self.method)
    
    parameters = []
    for param_name, param in sig.parameters.items():
        if param_name == 'self':
            continue
        
        # è·å–ç±»å‹
        param_type = type_hints.get(param_name, str)
        tool_type = self._python_type_to_tool_type(param_type)
        
        # åˆ¤æ–­æ˜¯å¦å¿…éœ€
        required = param.default == inspect.Parameter.empty
        default = None if required else param.default
        
        # è·å–æè¿°ï¼ˆä» docstringï¼‰
        description = self._get_param_description(param_name)
        
        parameters.append(ToolParameter(
            name=param_name,
            type=tool_type,
            description=description,
            required=required,
            default=default
        ))
    
    return parameters
```

#### 2. ä» docstring æå–æè¿°

```python
def _parse_param_descriptions(self, docstring: str) -> Dict[str, str]:
    """ä» docstring è§£æå‚æ•°æè¿°
    
    æ”¯æŒæ ¼å¼:
        Args:
            param_name: å‚æ•°æè¿°
            another_param: å¦ä¸€ä¸ªå‚æ•°æè¿°
    """
    descriptions = {}
    
    # æŸ¥æ‰¾ Args: éƒ¨åˆ†
    args_match = re.search(r'Args:\s*\n(.*?)(?:\n\s*\n|Returns:|$)', 
                          docstring, re.DOTALL)
    if not args_match:
        return descriptions
    
    args_section = args_match.group(1)
    
    # è§£ææ¯ä¸ªå‚æ•°
    param_pattern = r'^\s*(\w+)(?:\s*\([^)]+\))?\s*:\s*(.+?)(?=^\s*\w+\s*(?:\([^)]+\))?\s*:|$)'
    matches = re.finditer(param_pattern, args_section, re.MULTILINE | re.DOTALL)
    
    for match in matches:
        param_name = match.group(1).strip()
        param_desc = match.group(2).strip()
        param_desc = re.sub(r'\s+', ' ', param_desc)
        descriptions[param_name] = param_desc
    
    return descriptions
```

#### 3. ç±»å‹è½¬æ¢

```python
def _python_type_to_tool_type(self, py_type) -> str:
    """å°† Python ç±»å‹è½¬æ¢ä¸ºå·¥å…·ç±»å‹"""
    
    # å¤„ç†æ³›å‹ç±»å‹
    origin = getattr(py_type, '__origin__', None)
    if origin is not None:
        if origin is list:
            return "array"
        elif origin is dict:
            return "object"
    
    # å¤„ç†åŸºæœ¬ç±»å‹
    type_map = {
        str: "string",
        int: "integer",
        float: "number",
        bool: "boolean",
        list: "array",
        dict: "object",
    }
    
    return type_map.get(py_type, "string")
```

### å®Œæ•´ç¤ºä¾‹

```python
@tool_action("calculate", "æ‰§è¡Œæ•°å­¦è®¡ç®—")
def _calculate(self, expression: str, precision: int = 2) -> str:
    """æ‰§è¡Œæ•°å­¦è®¡ç®—
    
    Args:
        expression: æ•°å­¦è¡¨è¾¾å¼ï¼Œå¦‚ "2 + 3 * 4"
        precision: ç»“æœç²¾åº¦ï¼Œä¿ç•™å°æ•°ä½æ•°
    
    Returns:
        è®¡ç®—ç»“æœå­—ç¬¦ä¸²
    """
    result = eval(expression)
    return f"{result:.{precision}f}"
```

**è‡ªåŠ¨ç”Ÿæˆçš„å‚æ•°å®šä¹‰**ï¼š
```python
[
    ToolParameter(
        name="expression",
        type="string",
        description="æ•°å­¦è¡¨è¾¾å¼ï¼Œå¦‚ \"2 + 3 * 4\"",
        required=True
    ),
    ToolParameter(
        name="precision",
        type="integer",
        description="ç»“æœç²¾åº¦ï¼Œä¿ç•™å°æ•°ä½æ•°",
        required=False,
        default=2
    )
]
```

---

## å·¥å…·é“¾è¯¦è§£

### ToolChain ç±»

**æ ¸å¿ƒæ¦‚å¿µ**ï¼šå°†å¤šä¸ªå·¥å…·æŒ‰é¡ºåºç»„åˆæ‰§è¡Œï¼Œå‰ä¸€ä¸ªå·¥å…·çš„è¾“å‡ºä½œä¸ºåä¸€ä¸ªå·¥å…·çš„è¾“å…¥ã€‚

```python
class ToolChain:
    """å·¥å…·é“¾ - æ”¯æŒå¤šä¸ªå·¥å…·çš„é¡ºåºæ‰§è¡Œ"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.steps: List[Dict[str, Any]] = []
```

### æ ¸å¿ƒæ–¹æ³•

#### 1. add_step() - æ·»åŠ æ‰§è¡Œæ­¥éª¤

```python
def add_step(self, tool_name: str, input_template: str, output_key: str = None):
    """æ·»åŠ å·¥å…·æ‰§è¡Œæ­¥éª¤åˆ°å·¥å…·é“¾"""
    step = {
        "tool_name": tool_name,
        "input_template": input_template,
        "output_key": output_key or f"step_{len(self.steps)}_result"
    }
    self.steps.append(step)
```

**å‚æ•°è¯´æ˜**ï¼š
- `tool_name`: è¦æ‰§è¡Œçš„å·¥å…·åç§°
- `input_template`: è¾“å…¥æ¨¡æ¿ï¼Œæ”¯æŒ `{å˜é‡å}` æ ¼å¼
- `output_key`: è¾“å‡ºç»“æœçš„é”®åï¼Œç”¨äºåç»­æ­¥éª¤å¼•ç”¨

**æ¨¡æ¿å˜é‡ç¤ºä¾‹**ï¼š
```python
# ä½¿ç”¨åˆå§‹è¾“å…¥
input_template = "{input}"

# ä½¿ç”¨å‰ä¸€æ­¥éª¤çš„è¾“å‡º
input_template = "{search_result}"

# ç»„åˆå¤šä¸ªå˜é‡
input_template = "æ ¹æ® {search_result} è®¡ç®— {formula}"
```

#### 2. execute() - æ‰§è¡Œå·¥å…·é“¾

```python
def execute(self, registry: ToolRegistry, input_data: str, context: Dict[str, Any] = None) -> str:
    """æ‰§è¡Œå·¥å…·é“¾ä¸­çš„æ‰€æœ‰æ­¥éª¤"""
    
    # åˆå§‹åŒ–ä¸Šä¸‹æ–‡
    if context is None:
        context = {}
    context["input"] = input_data
    
    # é¡ºåºæ‰§è¡Œæ¯ä¸ªæ­¥éª¤
    for i, step in enumerate(self.steps):
        tool_name = step["tool_name"]
        input_template = step["input_template"]
        output_key = step["output_key"]
        
        # æ›¿æ¢æ¨¡æ¿å˜é‡
        actual_input = input_template.format(**context)
        
        # æ‰§è¡Œå·¥å…·
        result = registry.execute_tool(tool_name, actual_input)
        
        # ä¿å­˜ç»“æœåˆ°ä¸Šä¸‹æ–‡
        context[output_key] = result
        final_result = result
    
    return final_result
```

**æ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph TD
    A[å¼€å§‹æ‰§è¡Œ] --> B[åˆå§‹åŒ–ä¸Šä¸‹æ–‡]
    B --> C[context['input'] = input_data]
    C --> D[éå†æ­¥éª¤]
    D --> E[æ›¿æ¢æ¨¡æ¿å˜é‡]
    E --> F[æ‰§è¡Œå·¥å…·]
    F --> G[ä¿å­˜ç»“æœåˆ°ä¸Šä¸‹æ–‡]
    G --> H{è¿˜æœ‰æ­¥éª¤?}
    H -->|æ˜¯| D
    H -->|å¦| I[è¿”å›æœ€ç»ˆç»“æœ]
```

### ToolChainManager ç±»

**ä½œç”¨**ï¼šç®¡ç†å¤šä¸ªå·¥å…·é“¾çš„æ³¨å†Œå’Œæ‰§è¡Œã€‚

```python
class ToolChainManager:
    """å·¥å…·é“¾ç®¡ç†å™¨"""
    
    def __init__(self, registry: ToolRegistry):
        self.registry = registry
        self.chains: Dict[str, ToolChain] = {}
    
    def register_chain(self, chain: ToolChain):
        """æ³¨å†Œå·¥å…·é“¾"""
        self.chains[chain.name] = chain
    
    def execute_chain(self, chain_name: str, input_data: str, context: Dict[str, Any] = None) -> str:
        """æ‰§è¡ŒæŒ‡å®šå·¥å…·é“¾"""
        if chain_name not in self.chains:
            return f"é”™è¯¯ï¼šå·¥å…·é“¾ '{chain_name}' ä¸å­˜åœ¨"
        
        chain = self.chains[chain_name]
        return chain.execute(self.registry, input_data, context)
```

### å®æˆ˜ç¤ºä¾‹ï¼šåˆ›å»ºå·¥å…·é“¾

#### ç¤ºä¾‹ 1: ç®€å•å·¥å…·é“¾

```python
from hello_agents.tools.chain import ToolChain
from hello_agents.tools.registry import ToolRegistry

# åˆ›å»ºæ³¨å†Œè¡¨å’Œå·¥å…·
registry = ToolRegistry()
# ... æ³¨å†Œå·¥å…· ...

# åˆ›å»ºå·¥å…·é“¾
chain = ToolChain(
    name="data_process",
    description="æ•°æ®å¤„ç†æµç¨‹"
)

# æ·»åŠ æ­¥éª¤
chain.add_step(
    tool_name="fetch_data",
    input_template="{input}",
    output_key="raw_data"
)

chain.add_step(
    tool_name="clean_data",
    input_template="{raw_data}",
    output_key="clean_data"
)

chain.add_step(
    tool_name="analyze_data",
    input_template="{clean_data}",
    output_key="analysis"
)

# æ‰§è¡Œå·¥å…·é“¾
result = chain.execute(registry, "https://api.example.com/data")
print(result)
```

#### ç¤ºä¾‹ 2: ç ”ç©¶å·¥å…·é“¾

```python
# åˆ›å»ºç ”ç©¶å·¥å…·é“¾ï¼šæœç´¢ -> æ€»ç»“ -> ä¿å­˜
research_chain = ToolChain(
    name="research",
    description="ç ”ç©¶å¹¶ä¿å­˜ä¿¡æ¯"
)

# æ­¥éª¤1: æœç´¢
research_chain.add_step(
    tool_name="web_search",
    input_template="{input}",
    output_key="search_results"
)

# æ­¥éª¤2: æ€»ç»“
research_chain.add_step(
    tool_name="summarize",
    input_template="è¯·æ€»ç»“ä»¥ä¸‹å†…å®¹ï¼š{search_results}",
    output_key="summary"
)

# æ­¥éª¤3: ä¿å­˜
research_chain.add_step(
    tool_name="save_file",
    input_template="{summary}",
    output_key="file_path"
)

# æ‰§è¡Œ
result = research_chain.execute(registry, "Python Agent æ¡†æ¶")
```

#### ç¤ºä¾‹ 3: ä½¿ç”¨ç®¡ç†å™¨

```python
from hello_agents.tools.chain import ToolChainManager

# åˆ›å»ºç®¡ç†å™¨
manager = ToolChainManager(registry)

# æ³¨å†Œå¤šä¸ªå·¥å…·é“¾
manager.register_chain(research_chain)
manager.register_chain(data_process_chain)

# åˆ—å‡ºæ‰€æœ‰å·¥å…·é“¾
print(manager.list_chains())
# ['research', 'data_process']

# æ‰§è¡Œå·¥å…·é“¾
result = manager.execute_chain("research", "AI Agent")

# è·å–å·¥å…·é“¾ä¿¡æ¯
info = manager.get_chain_info("research")
print(f"å·¥å…·é“¾: {info['name']}")
print(f"æ­¥éª¤æ•°: {info['steps']}")
```

### å·¥å…·é“¾çš„ä¼˜åŠ¿

**1. å¤ç”¨æ€§**
```python
# å®šä¹‰ä¸€æ¬¡ï¼Œå¤šæ¬¡ä½¿ç”¨
chain = create_research_chain()
result1 = chain.execute(registry, "ä¸»é¢˜1")
result2 = chain.execute(registry, "ä¸»é¢˜2")
```

**2. å¯ç»´æŠ¤æ€§**
```python
# ä¿®æ”¹æµç¨‹åªéœ€ä¿®æ”¹å·¥å…·é“¾å®šä¹‰
chain.add_step(...)  # æ·»åŠ æ–°æ­¥éª¤
```

**3. å¯ç»„åˆæ€§**
```python
# å·¥å…·é“¾å¯ä»¥åµŒå¥—
chain1 = create_data_fetch_chain()
chain2 = create_analysis_chain()
# å¯ä»¥ç»„åˆæˆæ›´å¤§çš„å·¥å…·é“¾
```

---

## å¼‚æ­¥æ‰§è¡Œå™¨è¯¦è§£

### AsyncToolExecutor ç±»

**æ ¸å¿ƒæ¦‚å¿µ**ï¼šæ”¯æŒå·¥å…·çš„å¼‚æ­¥å’Œå¹¶è¡Œæ‰§è¡Œï¼Œæé«˜æ•ˆç‡ã€‚

```python
class AsyncToolExecutor:
    """å¼‚æ­¥å·¥å…·æ‰§è¡Œå™¨"""
    
    def __init__(self, registry: ToolRegistry, max_workers: int = 4):
        self.registry = registry
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=max_workers)
```

**å…³é”®å‚æ•°**ï¼š
- `registry`: å·¥å…·æ³¨å†Œè¡¨
- `max_workers`: æœ€å¤§å¹¶å‘çº¿ç¨‹æ•°ï¼ˆé»˜è®¤ 4ï¼‰

### æ ¸å¿ƒæ–¹æ³•

#### 1. execute_tool_async() - å¼‚æ­¥æ‰§è¡Œå•ä¸ªå·¥å…·

```python
async def execute_tool_async(self, tool_name: str, input_data: str) -> str:
    """å¼‚æ­¥æ‰§è¡Œå•ä¸ªå·¥å…·"""
    loop = asyncio.get_event_loop()
    
    def _execute():
        return self.registry.execute_tool(tool_name, input_data)
    
    try:
        result = await loop.run_in_executor(self.executor, _execute)
        return result
    except Exception as e:
        return f"âŒ å·¥å…· '{tool_name}' å¼‚æ­¥æ‰§è¡Œå¤±è´¥: {e}"
```

**å·¥ä½œåŸç†**ï¼š
- ä½¿ç”¨çº¿ç¨‹æ± æ‰§è¡Œå™¨ï¼ˆThreadPoolExecutorï¼‰
- å°†åŒæ­¥å·¥å…·è°ƒç”¨åŒ…è£…ä¸ºå¼‚æ­¥ä»»åŠ¡
- ä¸é˜»å¡äº‹ä»¶å¾ªç¯

#### 2. execute_tools_parallel() - å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·

```python
async def execute_tools_parallel(self, tasks: List[Dict[str, str]]) -> List[Dict[str, Any]]:
    """å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·"""
    
    # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
    async_tasks = []
    for i, task in enumerate(tasks):
        tool_name = task.get("tool_name")
        input_data = task.get("input_data", "")
        
        async_task = self.execute_tool_async(tool_name, input_data)
        async_tasks.append((i, task, async_task))
    
    # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    results = []
    for i, task, async_task in async_tasks:
        result = await async_task
        results.append({
            "task_id": i,
            "tool_name": task["tool_name"],
            "result": result,
            "status": "success"
        })
    
    return results
```

**å¹¶è¡Œæ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph TD
    A[æ¥æ”¶ä»»åŠ¡åˆ—è¡¨] --> B[åˆ›å»ºå¼‚æ­¥ä»»åŠ¡]
    B --> C[Task 1]
    B --> D[Task 2]
    B --> E[Task 3]
    B --> F[Task N]
    C --> G[å¹¶è¡Œæ‰§è¡Œ]
    D --> G
    E --> G
    F --> G
    G --> H[æ”¶é›†ç»“æœ]
    H --> I[è¿”å›ç»“æœåˆ—è¡¨]
```

#### 3. execute_tools_batch() - æ‰¹é‡æ‰§è¡ŒåŒä¸€å·¥å…·

```python
async def execute_tools_batch(self, tool_name: str, input_list: List[str]) -> List[Dict[str, Any]]:
    """æ‰¹é‡æ‰§è¡ŒåŒä¸€ä¸ªå·¥å…·"""
    tasks = [
        {"tool_name": tool_name, "input_data": input_data}
        for input_data in input_list
    ]
    return await self.execute_tools_parallel(tasks)
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- å¯¹å¤šä¸ªæ•°æ®æ‰§è¡Œç›¸åŒæ“ä½œ
- æ‰¹é‡æœç´¢ã€æ‰¹é‡è®¡ç®—ç­‰

### ä¾¿æ·å‡½æ•°

#### å¼‚æ­¥ç‰ˆæœ¬

```python
# å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·
async def run_parallel_tools(registry: ToolRegistry, tasks: List[Dict[str, str]], max_workers: int = 4):
    async with AsyncToolExecutor(registry, max_workers) as executor:
        return await executor.execute_tools_parallel(tasks)

# æ‰¹é‡æ‰§è¡ŒåŒä¸€å·¥å…·
async def run_batch_tool(registry: ToolRegistry, tool_name: str, input_list: List[str], max_workers: int = 4):
    async with AsyncToolExecutor(registry, max_workers) as executor:
        return await executor.execute_tools_batch(tool_name, input_list)
```

#### åŒæ­¥ç‰ˆæœ¬ï¼ˆå…¼å®¹æ€§ï¼‰

```python
# åŒæ­¥åŒ…è£…
def run_parallel_tools_sync(registry: ToolRegistry, tasks: List[Dict[str, str]], max_workers: int = 4):
    return asyncio.run(run_parallel_tools(registry, tasks, max_workers))

def run_batch_tool_sync(registry: ToolRegistry, tool_name: str, input_list: List[str], max_workers: int = 4):
    return asyncio.run(run_batch_tool(registry, tool_name, input_list, max_workers))
```

### å®æˆ˜ç¤ºä¾‹ï¼šå¼‚æ­¥æ‰§è¡Œ

#### ç¤ºä¾‹ 1: å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä¸åŒå·¥å…·

```python
import asyncio
from hello_agents.tools.async_executor import AsyncToolExecutor

async def main():
    # åˆ›å»ºæ‰§è¡Œå™¨
    executor = AsyncToolExecutor(registry, max_workers=4)
    
    # å®šä¹‰ä»»åŠ¡
    tasks = [
        {"tool_name": "web_search", "input_data": "Python"},
        {"tool_name": "calculator", "input_data": "2 + 2"},
        {"tool_name": "get_weather", "input_data": "åŒ—äº¬"},
        {"tool_name": "translate", "input_data": "Hello"}
    ]
    
    # å¹¶è¡Œæ‰§è¡Œ
    results = await executor.execute_tools_parallel(tasks)
    
    # æ˜¾ç¤ºç»“æœ
    for result in results:
        print(f"âœ… {result['tool_name']}: {result['result']}")

# è¿è¡Œ
asyncio.run(main())
```

#### ç¤ºä¾‹ 2: æ‰¹é‡æ‰§è¡ŒåŒä¸€å·¥å…·

```python
async def batch_search():
    executor = AsyncToolExecutor(registry, max_workers=8)
    
    # æ‰¹é‡æœç´¢
    queries = [
        "Python Agent",
        "LangChain",
        "OpenAI API",
        "RAG ç³»ç»Ÿ",
        "å‘é‡æ•°æ®åº“"
    ]
    
    results = await executor.execute_tools_batch("web_search", queries)
    
    # å¤„ç†ç»“æœ
    for result in results:
        print(f"æŸ¥è¯¢: {result['input_data']}")
        print(f"ç»“æœ: {result['result']}\n")

asyncio.run(batch_search())
```

#### ç¤ºä¾‹ 3: ä½¿ç”¨åŒæ­¥ç‰ˆæœ¬

```python
from hello_agents.tools.async_executor import run_parallel_tools_sync

# ä¸éœ€è¦ async/await
tasks = [
    {"tool_name": "tool1", "input_data": "data1"},
    {"tool_name": "tool2", "input_data": "data2"}
]

results = run_parallel_tools_sync(registry, tasks)
print(results)
```

### æ€§èƒ½å¯¹æ¯”

**é¡ºåºæ‰§è¡Œ vs å¹¶è¡Œæ‰§è¡Œ**ï¼š

```python
import time

# é¡ºåºæ‰§è¡Œ
start = time.time()
for task in tasks:
    result = registry.execute_tool(task["tool_name"], task["input_data"])
sequential_time = time.time() - start

# å¹¶è¡Œæ‰§è¡Œ
start = time.time()
results = run_parallel_tools_sync(registry, tasks, max_workers=4)
parallel_time = time.time() - start

print(f"é¡ºåºæ‰§è¡Œ: {sequential_time:.2f}s")
print(f"å¹¶è¡Œæ‰§è¡Œ: {parallel_time:.2f}s")
print(f"åŠ é€Ÿæ¯”: {sequential_time / parallel_time:.2f}x")
```

**å…¸å‹ç»“æœ**ï¼š
```
é¡ºåºæ‰§è¡Œ: 10.50s
å¹¶è¡Œæ‰§è¡Œ: 3.20s
åŠ é€Ÿæ¯”: 3.28x
```

### ä½¿ç”¨åœºæ™¯

| åœºæ™¯ | æ¨èæ–¹å¼ | åŸå›  |
|------|---------|------|
| å•ä¸ªå·¥å…·è°ƒç”¨ | åŒæ­¥æ‰§è¡Œ | ç®€å•ç›´æ¥ |
| å¤šä¸ªç‹¬ç«‹å·¥å…· | å¹¶è¡Œæ‰§è¡Œ | æé«˜æ•ˆç‡ |
| æ‰¹é‡ç›¸åŒæ“ä½œ | æ‰¹é‡æ‰§è¡Œ | ä»£ç ç®€æ´ |
| å·¥å…·æœ‰ä¾èµ–å…³ç³» | å·¥å…·é“¾ | ä¿è¯é¡ºåº |
| æ··åˆåœºæ™¯ | å·¥å…·é“¾ + å¼‚æ­¥ | çµæ´»ç»„åˆ |

### æ³¨æ„äº‹é¡¹

**1. çº¿ç¨‹å®‰å…¨**
```python
# âš ï¸ ç¡®ä¿å·¥å…·æ˜¯çº¿ç¨‹å®‰å…¨çš„
class ThreadSafeTool(Tool):
    def __init__(self):
        super().__init__(...)
        self.lock = threading.Lock()
    
    def run(self, parameters):
        with self.lock:
            # çº¿ç¨‹å®‰å…¨çš„æ“ä½œ
            pass
```

**2. èµ„æºé™åˆ¶**
```python
# æ§åˆ¶å¹¶å‘æ•°ï¼Œé¿å…èµ„æºè€—å°½
executor = AsyncToolExecutor(registry, max_workers=4)  # ä¸è¦è®¾ç½®å¤ªå¤§
```

**3. é”™è¯¯å¤„ç†**
```python
# å¹¶è¡Œæ‰§è¡Œæ—¶ï¼Œå•ä¸ªä»»åŠ¡å¤±è´¥ä¸å½±å“å…¶ä»–ä»»åŠ¡
results = await executor.execute_tools_parallel(tasks)
for result in results:
    if result["status"] == "error":
        print(f"ä»»åŠ¡å¤±è´¥: {result['tool_name']}")
```

---

## å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1: åˆ›å»ºç®€å•å·¥å…·

```python
from hello_agents.tools.base import Tool, ToolParameter

class CalculatorTool(Tool):
    """è®¡ç®—å™¨å·¥å…·"""
    
    def __init__(self):
        super().__init__(
            name="calculator",
            description="æ‰§è¡Œæ•°å­¦è®¡ç®—"
        )
    
    def run(self, parameters: Dict[str, Any]) -> str:
        expression = parameters.get('expression', '')
        try:
            result = eval(expression)
            return f"è®¡ç®—ç»“æœ: {result}"
        except Exception as e:
            return f"è®¡ç®—é”™è¯¯: {str(e)}"
    
    def get_parameters(self) -> List[ToolParameter]:
        return [
            ToolParameter(
                name="expression",
                type="string",
                description="æ•°å­¦è¡¨è¾¾å¼",
                required=True
            )
        ]

# ä½¿ç”¨
tool = CalculatorTool()
result = tool.run({"expression": "2 + 3 * 4"})
print(result)  # è®¡ç®—ç»“æœ: 14
```

### ç¤ºä¾‹ 2: åˆ›å»ºå¯å±•å¼€å·¥å…·

```python
class FileSystemTool(Tool):
    """æ–‡ä»¶ç³»ç»Ÿå·¥å…·ï¼ˆå¯å±•å¼€ï¼‰"""
    
    def __init__(self):
        super().__init__(
            name="filesystem",
            description="æ–‡ä»¶ç³»ç»Ÿæ“ä½œå·¥å…·",
            expandable=True
        )
    
    @tool_action("read", "è¯»å–æ–‡ä»¶")
    def _read_file(self, path: str) -> str:
        """è¯»å–æ–‡ä»¶å†…å®¹
        
        Args:
            path: æ–‡ä»¶è·¯å¾„
        """
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            return f"è¯»å–å¤±è´¥: {str(e)}"
    
    @tool_action("write", "å†™å…¥æ–‡ä»¶")
    def _write_file(self, path: str, content: str) -> str:
        """å†™å…¥æ–‡ä»¶å†…å®¹
        
        Args:
            path: æ–‡ä»¶è·¯å¾„
            content: è¦å†™å…¥çš„å†…å®¹
        """
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(content)
            return f"å·²å†™å…¥ {len(content)} ä¸ªå­—ç¬¦"
        except Exception as e:
            return f"å†™å…¥å¤±è´¥: {str(e)}"
    
    @tool_action("list", "åˆ—å‡ºç›®å½•")
    def _list_dir(self, path: str = ".") -> str:
        """åˆ—å‡ºç›®å½•å†…å®¹
        
        Args:
            path: ç›®å½•è·¯å¾„ï¼Œé»˜è®¤å½“å‰ç›®å½•
        """
        import os
        try:
            files = os.listdir(path)
            return "\n".join(files)
        except Exception as e:
            return f"åˆ—å‡ºå¤±è´¥: {str(e)}"

# ä½¿ç”¨
registry = ToolRegistry()
fs_tool = FileSystemTool()
registry.register_tool(fs_tool)

# è‡ªåŠ¨æ³¨å†Œäº† 3 ä¸ªå·¥å…·
print(registry.list_tools())
# ['filesystem_read', 'filesystem_write', 'filesystem_list']
```

### ç¤ºä¾‹ 3: å‡½æ•°æ³¨å†Œæ–¹å¼

```python
registry = ToolRegistry()

# å¿«é€Ÿæ³¨å†Œç®€å•å·¥å…·
def get_time(input_text: str) -> str:
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

registry.register_function(
    name="get_time",
    description="è·å–å½“å‰æ—¶é—´",
    func=get_time
)

# ä½¿ç”¨
result = registry.execute_tool("get_time", "")
print(result)  # 2024-01-24 14:30:00
```

### ç¤ºä¾‹ 4: åœ¨ Agent ä¸­ä½¿ç”¨å·¥å…·

```python
from hello_agents import MySimpleAgent, HelloAgentsLLM, ToolRegistry

# åˆ›å»ºå·¥å…·
calculator = CalculatorTool()
fs_tool = FileSystemTool()

# åˆ›å»ºæ³¨å†Œè¡¨
registry = ToolRegistry()
registry.register_tool(calculator)
registry.register_tool(fs_tool)

# åˆ›å»º Agent
llm = HelloAgentsLLM(provider="deepseek")
agent = MySimpleAgent(
    name="Assistant",
    llm=llm,
    tool_registry=registry,
    enable_tool_calling=True
)

# è¿è¡Œ
response = agent.run("å¸®æˆ‘è®¡ç®— 123 * 456")
print(response)
```

---

## å­¦ä¹ æ£€æŸ¥æ¸…å•

### åŸºç¡€ç†è§£
- [ ] ç†è§£ Tool åŸºç±»çš„è®¾è®¡
- [ ] æŒæ¡ä¸¤ç§å·¥å…·æ³¨å†Œæ–¹å¼
- [ ] äº†è§£ expandable çš„ä½œç”¨
- [ ] ç†è§£å‚æ•°å®šä¹‰çš„ç»“æ„
- [ ] ç†è§£å·¥å…·é“¾çš„æ¦‚å¿µ
- [ ] äº†è§£å¼‚æ­¥æ‰§è¡Œçš„ä¼˜åŠ¿

### è¿›é˜¶æŒæ¡
- [ ] æŒæ¡ @tool_action è£…é¥°å™¨
- [ ] ç†è§£è‡ªåŠ¨å‚æ•°è§£ææœºåˆ¶
- [ ] èƒ½å¤Ÿåˆ›å»ºå¯å±•å¼€å·¥å…·
- [ ] ç†è§£ OpenAI schema è½¬æ¢
- [ ] æŒæ¡å·¥å…·é“¾çš„æ¨¡æ¿å˜é‡æœºåˆ¶
- [ ] ç†è§£å¼‚æ­¥æ‰§è¡Œçš„å·¥ä½œåŸç†

### å®æˆ˜åº”ç”¨
- [ ] åˆ›å»ºè‡³å°‘ 3 ä¸ªè‡ªå®šä¹‰å·¥å…·
- [ ] å®ç°ä¸€ä¸ªå¯å±•å¼€å·¥å…·
- [ ] åœ¨ Agent ä¸­é›†æˆå·¥å…·
- [ ] å¤„ç†å·¥å…·æ‰§è¡Œçš„é”™è¯¯
- [ ] åˆ›å»ºä¸€ä¸ªå¤šæ­¥éª¤å·¥å…·é“¾
- [ ] ä½¿ç”¨å¼‚æ­¥æ‰§è¡Œå™¨å¹¶è¡Œæ‰§è¡Œå·¥å…·
- [ ] å¯¹æ¯”é¡ºåºæ‰§è¡Œå’Œå¹¶è¡Œæ‰§è¡Œçš„æ€§èƒ½

### é«˜çº§åº”ç”¨
- [ ] è®¾è®¡å¤æ‚çš„å·¥å…·é“¾æµç¨‹
- [ ] å®ç°çº¿ç¨‹å®‰å…¨çš„å·¥å…·
- [ ] ç»„åˆå·¥å…·é“¾å’Œå¼‚æ­¥æ‰§è¡Œ
- [ ] ä¼˜åŒ–å·¥å…·æ‰§è¡Œæ€§èƒ½

---

**ä¸‹ä¸€æ­¥å­¦ä¹ **: [ReAct Agent è¯¦è§£](./05_ReActAgentè¯¦è§£.md)
