# 记忆系统详解

> 为 Agent 添加短期和长期记忆，实现多轮对话和跨会话信息存储

AI 应用需要记忆来在多次交互中共享上下文。LangGraph 支持两种类型的记忆：

| 类型 | 说明 | 实现方式 |
|------|------|----------|
| **短期记忆** | 线程级持久化，支持多轮对话 | Checkpointer |
| **长期记忆** | 跨会话存储用户/应用数据 | Store |

```mermaid
graph TB
    subgraph 短期记忆
        A[Thread 1] --> B[对话历史]
        C[Thread 2] --> D[对话历史]
    end
    
    subgraph 长期记忆
        E[User 1] --> F[用户偏好/记忆]
        G[User 2] --> H[用户偏好/记忆]
    end
    
    B -.->|同一 thread_id| B
    F -.->|跨 thread_id| F
```

## 添加短期记忆

短期记忆通过 **Checkpointer** 实现，使 Agent 能够跟踪多轮对话：

```python
from langgraph.checkpoint.memory import InMemorySaver
from langgraph.graph import StateGraph

checkpointer = InMemorySaver()

builder = StateGraph(...)
graph = builder.compile(checkpointer=checkpointer)

# 使用 thread_id 标识对话
graph.invoke(
    {"messages": [{"role": "user", "content": "hi! i am Bob"}]},
    {"configurable": {"thread_id": "1"}},
)
```

### 生产环境

使用数据库支持的 Checkpointer：

| Checkpointer | 安装包 | 适用场景 |
|--------------|--------|----------|
| `PostgresSaver` | `langgraph-checkpoint-postgres` | 生产环境首选 |
| `MongoDBSaver` | `langgraph-checkpoint-mongodb` | MongoDB 用户 |
| `RedisSaver` | `langgraph-checkpoint-redis` | 高性能缓存 |

```python
from langgraph.checkpoint.postgres import PostgresSaver

DB_URI = "postgresql://postgres:postgres@localhost:5442/postgres?sslmode=disable"

with PostgresSaver.from_conn_string(DB_URI) as checkpointer:
    # 首次使用需要调用 checkpointer.setup()
    builder = StateGraph(...)
    graph = builder.compile(checkpointer=checkpointer)
```

### 子图中使用

只需在**父图**编译时提供 Checkpointer，LangGraph 会自动传播到子图：

```python
from langgraph.graph import START, StateGraph
from langgraph.checkpoint.memory import InMemorySaver

# 子图（不需要指定 checkpointer）
subgraph_builder = StateGraph(State)
subgraph_builder.add_node(subgraph_node_1)
subgraph_builder.add_edge(START, "subgraph_node_1")
subgraph = subgraph_builder.compile()

# 父图
builder = StateGraph(State)
builder.add_node("node_1", subgraph)
builder.add_edge(START, "node_1")

checkpointer = InMemorySaver()
graph = builder.compile(checkpointer=checkpointer)  # 只在父图指定
```

如果希望子图有**独立的记忆**（如多 Agent 系统中各 Agent 保持独立消息历史）：

```python
subgraph = subgraph_builder.compile(checkpointer=True)  # 子图独立记忆
```

## 添加长期记忆

长期记忆通过 **Store** 实现，用于跨会话存储用户或应用数据：

```python
from langgraph.store.memory import InMemoryStore
from langgraph.graph import StateGraph

store = InMemoryStore()

builder = StateGraph(...)
graph = builder.compile(store=store)
```

### 生产环境

```python
from langgraph.store.postgres import PostgresStore

DB_URI = "postgresql://postgres:postgres@localhost:5442/postgres?sslmode=disable"

with PostgresStore.from_conn_string(DB_URI) as store:
    # 首次使用需要调用 store.setup()
    builder = StateGraph(...)
    graph = builder.compile(store=store)
```

### 在节点中使用 Store

```python
from langgraph.store.base import BaseStore
from langchain_core.runnables import RunnableConfig
import uuid

def call_model(
    state: MessagesState,
    config: RunnableConfig,
    *,
    store: BaseStore,  # 通过参数注入
):
    user_id = config["configurable"]["user_id"]
    namespace = ("memories", user_id)
    
    # 搜索记忆
    memories = store.search(namespace, query=str(state["messages"][-1].content))
    info = "\n".join([d.value["data"] for d in memories])
    
    # 存储新记忆
    if "remember" in state["messages"][-1].content.lower():
        memory = "User name is Bob"
        store.put(namespace, str(uuid.uuid4()), {"data": memory})
    
    # 使用记忆构建系统消息
    system_msg = f"You are a helpful assistant. User info: {info}"
    response = model.invoke([{"role": "system", "content": system_msg}] + state["messages"])
    return {"messages": response}

# 编译时同时指定 checkpointer 和 store
graph = builder.compile(checkpointer=checkpointer, store=store)

# 调用时指定 thread_id 和 user_id
config = {"configurable": {"thread_id": "1", "user_id": "1"}}
graph.invoke({"messages": [...]}, config)
```

### 语义搜索

启用语义搜索，让 Agent 按语义相似度搜索记忆：

```python
from langchain.embeddings import init_embeddings
from langgraph.store.memory import InMemoryStore

# 创建支持语义搜索的 Store
embeddings = init_embeddings("openai:text-embedding-3-small")
store = InMemoryStore(
    index={
        "embed": embeddings,
        "dims": 1536,
    }
)

# 存储记忆
store.put(("user_123", "memories"), "1", {"text": "I love pizza"})
store.put(("user_123", "memories"), "2", {"text": "I am a plumber"})

# 语义搜索
items = store.search(("user_123", "memories"), query="I'm hungry", limit=1)
# 返回 "I love pizza"（语义相关）
```

## 管理短期记忆

长对话可能超出 LLM 的上下文窗口，常见解决方案：

| 策略 | 说明 |
|------|------|
| **裁剪消息** | 移除最早/最新的 N 条消息 |
| **删除消息** | 从状态中永久删除消息 |
| **摘要消息** | 用摘要替换早期消息 |
| **管理检查点** | 查看和删除检查点 |

### 裁剪消息 (trim_messages)

使用 `trim_messages` 按 token 数量裁剪：

```python
from langchain_core.messages.utils import trim_messages, count_tokens_approximately

def call_model(state: MessagesState):
    messages = trim_messages(
        state["messages"],
        strategy="last",  # 保留最后的消息
        token_counter=count_tokens_approximately,
        max_tokens=128,
        start_on="human",  # 从 human 消息开始
        end_on=("human", "tool"),  # 以 human 或 tool 消息结束
    )
    response = model.invoke(messages)
    return {"messages": [response]}
```

### 删除消息 (RemoveMessage)

使用 `RemoveMessage` 删除特定消息：

```python
from langchain.messages import RemoveMessage

def delete_messages(state):
    messages = state["messages"]
    if len(messages) > 2:
        # 删除最早的两条消息
        return {"messages": [RemoveMessage(id=m.id) for m in messages[:2]]}
```

删除**所有**消息：

```python
from langgraph.graph.message import REMOVE_ALL_MESSAGES

def delete_messages(state):
    return {"messages": [RemoveMessage(id=REMOVE_ALL_MESSAGES)]}
```

> **注意**：删除消息后确保消息历史有效。某些 LLM 要求以 `user` 消息开头，或 `assistant` 工具调用后必须跟 `tool` 结果。

### 摘要消息

裁剪/删除消息会丢失信息，更好的方式是用 LLM 生成摘要：

![Summary](fig/summary.avif)

```python
from langgraph.graph import MessagesState

class State(MessagesState):
    summary: str  # 添加摘要字段

def summarize_conversation(state: State):
    # 获取现有摘要
    summary = state.get("summary", "")
    
    # 构建摘要提示
    if summary:
        summary_message = (
            f"This is a summary of the conversation to date: {summary}\n\n"
            "Extend the summary by taking into account the new messages above:"
        )
    else:
        summary_message = "Create a summary of the conversation above:"
    
    # 生成摘要
    messages = state["messages"] + [HumanMessage(content=summary_message)]
    response = model.invoke(messages)
    
    # 删除旧消息，只保留最近 2 条
    delete_messages = [RemoveMessage(id=m.id) for m in state["messages"][:-2]]
    
    return {"summary": response.content, "messages": delete_messages}
```

### 管理检查点

#### 查看线程状态

```python
config = {"configurable": {"thread_id": "1"}}

# 获取最新状态
state = graph.get_state(config)
print(state.values["messages"])

# 获取特定检查点的状态
config = {"configurable": {
    "thread_id": "1",
    "checkpoint_id": "1f029ca3-1f5b-6704-8004-820c16b69a5a"
}}
state = graph.get_state(config)
```

#### 查看线程历史

```python
config = {"configurable": {"thread_id": "1"}}

# 获取完整历史（按时间倒序）
history = list(graph.get_state_history(config))
for state in history:
    print(state.values, state.next)
```

#### 删除线程检查点

```python
thread_id = "1"
checkpointer.delete_thread(thread_id)
```

## 数据库管理

使用数据库支持的持久化实现时，首次使用前需要运行迁移：

```python
# Checkpointer
checkpointer.setup()  # 同步
await checkpointer.asetup()  # 异步

# Store
store.setup()  # 同步
await store.asetup()  # 异步
```

> 建议将迁移作为独立的部署步骤，或在服务器启动时运行。

## 短期 vs 长期记忆对比

| 维度 | 短期记忆 | 长期记忆 |
|------|----------|----------|
| **实现** | Checkpointer | Store |
| **范围** | 单个 thread_id | 跨 thread_id |
| **用途** | 多轮对话上下文 | 用户偏好、历史信息 |
| **生命周期** | 对话期间 | 持久存储 |
| **访问方式** | 自动加载到状态 | 手动 search/put |

## 要点总结

- **短期记忆**：Checkpointer + thread_id，实现多轮对话
- **长期记忆**：Store + namespace，跨会话存储
- **语义搜索**：配置 embeddings 启用语义相似度搜索
- **消息管理**：trim_messages、RemoveMessage、摘要
- **生产环境**：使用 Postgres/MongoDB/Redis 等数据库支持
- **数据库迁移**：首次使用调用 `setup()` 方法
