# 前置后置处理机制详解

## 概述

在 LangGraph 中实现节点的前置/后置处理逻辑，类似于@before、@after的功能。

## 核心机制对比

### 1. 节点函数内实现（最推荐）⭐⭐⭐⭐⭐

**特点：**
- 所有逻辑集中在一个函数内
- 代码简单直接
- 易于理解和调试
- 90% 场景的首选方案

**示例：**

```python
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict

class AgentState(TypedDict):
    messages: list
    iterations: int

def call_model(state):
    """节点函数内实现所有逻辑"""
    
    # ===== 前置处理 =====
    print("[Before] 准备调用模型")
    messages = state["messages"]
    
    # 添加系统提示
    messages = [
        {"role": "system", "content": "你是一个专业的 AI 助手"}
    ] + messages
    
    # 验证输入
    if not messages:
        raise ValueError("消息列表不能为空")
    
    # ===== 核心逻辑 =====
    response = llm.invoke(messages)
    
    # ===== 后置处理 =====
    print(f"[After] 模型返回: {response.content[:50]}...")
    
    # 记录日志
    log_to_file(response)
    
    return {
        "messages": [response],
        "iterations": 1
    }

# 构建图
workflow = StateGraph(AgentState)
workflow.add_node("agent", call_model)
workflow.add_edge(START, "agent")
workflow.add_edge("agent", END)

app = workflow.compile()
```

**适用场景：**
- 简单的前后处理逻辑
- 逻辑紧密相关
- 不需要复用

---

### 2. 节点封装（图结构）⭐⭐⭐⭐

**特点：**
- 将前置/后置逻辑拆分为独立节点
- 流程清晰可见
- 易于调整和扩展
- 适合复杂业务流程

**示例：**

```python
from langgraph.graph import StateGraph, START, END
from typing_extensions import TypedDict

class AgentState(TypedDict):
    messages: list
    validated: bool
    iterations: int

def validate_input(state):
    """前置节点：验证输入"""
    print("[Before] 验证输入")
    
    messages = state["messages"]
    if not messages:
        raise ValueError("消息列表不能为空")
    
    return {"validated": True}

def add_system_prompt(state):
    """前置节点：添加系统提示"""
    print("[Before] 添加系统提示")
    
    messages = state["messages"]
    messages = [
        {"role": "system", "content": "你是专家"}
    ] + messages
    
    return {"messages": messages}

def call_model(state):
    """核心节点：调用模型"""
    print("[Core] 调用模型")
    
    response = llm.invoke(state["messages"])
    
    return {
        "messages": [response],
        "iterations": 1
    }

def log_response(state):
    """后置节点：记录日志"""
    print("[After] 记录日志")
    
    last_message = state["messages"][-1]
    log_to_file(last_message)
    
    return state

# 构建图：前置 → 核心 → 后置
workflow = StateGraph(AgentState)

workflow.add_node("validate", validate_input)
workflow.add_node("add_prompt", add_system_prompt)
workflow.add_node("model", call_model)
workflow.add_node("log", log_response)

# 定义流程
workflow.add_edge(START, "validate")
workflow.add_edge("validate", "add_prompt")
workflow.add_edge("add_prompt", "model")
workflow.add_edge("model", "log")
workflow.add_edge("log", END)

app = workflow.compile()
```

**适用场景：**
- 复杂的前后处理逻辑
- 需要条件分支
- 流程需要可视化
- 逻辑需要独立测试

**带条件分支的示例：**

```python
from typing import Literal

def should_add_prompt(state) -> Literal["add_prompt", "model"]:
    """条件判断：是否需要添加系统提示"""
    if state.get("skip_prompt"):
        return "model"
    return "add_prompt"

# 构建图
workflow = StateGraph(AgentState)
workflow.add_node("validate", validate_input)
workflow.add_node("add_prompt", add_system_prompt)
workflow.add_node("model", call_model)

workflow.add_edge(START, "validate")
workflow.add_conditional_edge(
    "validate",
    should_add_prompt,
    {
        "add_prompt": "add_prompt",
        "model": "model"
    }
)
workflow.add_edge("add_prompt", "model")
workflow.add_edge("model", END)
```

---

### 3. 装饰器模式 ⭐⭐

**特点：**
- 代码复用性高
- 适合横切关注点（日志、监控、错误处理）
- 可以组合多个装饰器
- 调试相对困难

**示例：**

```python
import time
from functools import wraps

def log_execution(func):
    """装饰器：记录执行日志"""
    @wraps(func)
    def wrapper(state):
        print(f"[Before] 开始执行: {func.__name__}")
        result = func(state)
        print(f"[After] 执行完成: {func.__name__}")
        return result
    return wrapper

def measure_time(func):
    """装饰器：测量执行时间"""
    @wraps(func)
    def wrapper(state):
        start = time.time()
        result = func(state)
        duration = time.time() - start
        print(f"[Metric] {func.__name__} 耗时: {duration:.2f}s")
        return result
    return wrapper

def add_system_prompt(func):
    """装饰器：添加系统提示"""
    @wraps(func)
    def wrapper(state):
        messages = state["messages"]
        state["messages"] = [
            {"role": "system", "content": "你是专家"}
        ] + messages
        return func(state)
    return wrapper

# 使用多个装饰器
@log_execution
@measure_time
@add_system_prompt
def call_model(state):
    """调用模型"""
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# 添加到图
workflow = StateGraph(AgentState)
workflow.add_node("agent", call_model)
workflow.add_edge(START, "agent")
workflow.add_edge("agent", END)
```

**装饰器执行顺序：**

```python
@decorator1
@decorator2
@decorator3
def func():
    pass

# 执行顺序：
# 1. decorator1 前置
# 2. decorator2 前置
# 3. decorator3 前置
# 4. func 核心逻辑
# 5. decorator3 后置
# 6. decorator2 后置
# 7. decorator1 后置
```

**适用场景：**
- 日志记录
- 性能监控
- 错误处理
- 权限检查
- 需要在多个节点复用的逻辑

---

## 三种机制对比

| 维度 | 节点函数内实现 | 节点封装 | 装饰器 |
|------|---------------|---------|--------|
| 代码复杂度 | 低 | 中 | 中 |
| 可读性 | 高 | 高 | 中 |
| 可维护性 | 高 | 高 | 中 |
| 复用性 | 低 | 中 | 高 |
| 灵活性 | 中 | 高 | 中 |
| 调试难度 | 低 | 低 | 高 |
| 流程可见性 | 低 | 高 | 低 |
| 适用场景 | 简单逻辑 | 复杂流程 | 通用功能 |

---

## 实际应用示例

### 场景1：简单的日志记录

**推荐：节点函数内实现**

```python
def call_model(state):
    print(f"[Log] 调用模型，消息数: {len(state['messages'])}")
    response = llm.invoke(state["messages"])
    print(f"[Log] 模型返回: {response.content[:50]}")
    return {"messages": [response]}
```

### 场景2：复杂的数据验证和转换

**推荐：节点封装**

```python
def validate_input(state):
    """验证输入格式"""
    if not state["messages"]:
        raise ValueError("消息不能为空")
    return state

def transform_format(state):
    """转换消息格式"""
    messages = convert_to_openai_format(state["messages"])
    return {"messages": messages}

def call_model(state):
    """调用模型"""
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# 构建流程
workflow.add_edge(START, "validate")
workflow.add_edge("validate", "transform")
workflow.add_edge("transform", "model")
```

### 场景3：多个节点需要相同的监控逻辑

**推荐：装饰器**

```python
def monitor(func):
    """监控装饰器"""
    def wrapper(state):
        start = time.time()
        try:
            result = func(state)
            duration = time.time() - start
            log_success(func.__name__, duration)
            return result
        except Exception as e:
            log_error(func.__name__, e)
            raise
    return wrapper

@monitor
def node1(state):
    return process1(state)

@monitor
def node2(state):
    return process2(state)

@monitor
def node3(state):
    return process3(state)
```

---

## 混合使用

实际项目中，通常会组合使用多种机制：

```python
# 装饰器：通用监控
def monitor(func):
    def wrapper(state):
        start = time.time()
        result = func(state)
        duration = time.time() - start
        print(f"{func.__name__} 耗时: {duration:.2f}s")
        return result
    return wrapper

# 前置节点：业务验证
def validate_input(state):
    if not state["messages"]:
        raise ValueError("消息不能为空")
    return state

# 核心节点：带装饰器和内部逻辑
@monitor
def call_model(state):
    # 节点内前置处理
    messages = state["messages"]
    messages = [{"role": "system", "content": "你是专家"}] + messages
    
    # 核心逻辑
    response = llm.invoke(messages)
    
    # 节点内后置处理
    print(f"返回: {response.content[:50]}")
    
    return {"messages": [response]}

# 后置节点：业务处理
def save_to_db(state):
    save_conversation(state["messages"])
    return state

# 构建图
workflow = StateGraph(AgentState)
workflow.add_node("validate", validate_input)
workflow.add_node("model", call_model)
workflow.add_node("save", save_to_db)

workflow.add_edge(START, "validate")
workflow.add_edge("validate", "model")
workflow.add_edge("model", "save")
workflow.add_edge("save", END)
```

---

## 选择建议

### 优先级

1. **默认选择：节点函数内实现**
   - 逻辑简单
   - 不需要复用
   - 快速开发

2. **复杂流程：节点封装**
   - 需要条件分支
   - 流程需要可视化
   - 逻辑需要独立测试

3. **通用功能：装饰器**
   - 日志、监控、错误处理
   - 需要在多个节点复用
   - 横切关注点

### 决策树

```
需要前置/后置处理？
├─ 是 → 逻辑简单？
│       ├─ 是 → 节点函数内实现
│       └─ 否 → 需要复用？
│               ├─ 是 → 装饰器
│               └─ 否 → 节点封装
└─ 否 → 直接实现核心逻辑
```

---

## 注意事项

### 1. 避免过度设计

```python
# ❌ 过度设计
@log
@monitor
@validate
@transform
def simple_node(state):
    return state

# ✅ 简单直接
def simple_node(state):
    print(f"处理: {state}")
    return state
```

### 2. 保持状态不可变

```python
# ❌ 直接修改状态
def bad_node(state):
    state["messages"].append(new_message)  # 危险！
    return state

# ✅ 返回新状态
def good_node(state):
    messages = state["messages"] + [new_message]
    return {"messages": messages}
```

### 3. 装饰器要保留函数元信息

```python
from functools import wraps

# ❌ 丢失函数信息
def bad_decorator(func):
    def wrapper(state):
        return func(state)
    return wrapper

# ✅ 保留函数信息
def good_decorator(func):
    @wraps(func)  # 保留 __name__, __doc__ 等
    def wrapper(state):
        return func(state)
    return wrapper
```

---

## 总结

- **节点函数内实现**：最常用，适合 90% 场景
- **节点封装**：复杂流程，需要可视化
- **装饰器**：通用功能，需要复用

选择原则：**简单优先，按需选择**。
