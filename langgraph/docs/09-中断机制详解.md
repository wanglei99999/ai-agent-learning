# 中断机制详解

> 在特定点暂停图执行，等待外部输入后继续，实现人机协作

**中断 (Interrupt)** 允许在图执行的特定点暂停，等待外部输入后再继续。这是实现人机协作 (Human-in-the-loop) 模式的核心机制。

## 核心概念

```mermaid
graph LR
    A[图执行] --> B[调用 interrupt]
    B --> C[保存状态到 Checkpointer]
    C --> D[返回中断值给调用者]
    D --> E[等待外部输入]
    E --> F["调用 Command(resume=...)"]
    F --> G[从节点开头恢复执行]
    G --> H[interrupt 返回 resume 值]
```

| 概念 | 说明 |
|------|------|
| **Checkpointer** | 保存图状态，使恢复成为可能 |
| **thread_id** | 持久化指针，标识要恢复的状态 |
| **`__interrupt__`** | 中断载荷返回给调用者的字段 |
| **Command(resume=...)** | 恢复执行并传入响应值 |

> 与静态断点不同，`interrupt()` 是**动态的**——可以放在代码任意位置，支持条件判断。

## 使用 interrupt 暂停

### 基本要求

1. **Checkpointer**：持久化图状态（生产环境使用持久化存储）
2. **thread_id**：在 config 中指定，用于恢复时定位状态
3. **JSON 可序列化**：`interrupt()` 的载荷必须可序列化

```python
from langgraph.types import interrupt

def approval_node(state: State):
    # 暂停并请求审批
    approved = interrupt("Do you approve this action?")
    # 恢复时，Command(resume=...) 的值成为这里的返回值
    return {"approved": approved}
```

### 执行流程

1. **图执行暂停**：在 `interrupt()` 调用点暂停
2. **状态保存**：通过 Checkpointer 保存状态
3. **返回值**：中断载荷通过 `__interrupt__` 返回给调用者
4. **无限等待**：直到调用者恢复执行
5. **传回响应**：恢复时的值成为 `interrupt()` 的返回值

## 恢复中断

使用 `Command(resume=...)` 恢复执行：

```python
from langgraph.types import Command

# 初始运行 - 遇到中断并暂停
config = {"configurable": {"thread_id": "thread-1"}}
result = graph.invoke({"input": "data"}, config=config)

# 检查中断内容
print(result["__interrupt__"])
# > [Interrupt(value='Do you approve this action?')]

# 恢复执行，传入响应值
graph.invoke(Command(resume=True), config=config)
```

### 恢复要点

| 要点 | 说明 |
|------|------|
| **相同 thread_id** | 恢复时必须使用相同的 thread_id |
| **resume 值** | `Command(resume=...)` 的值成为 `interrupt()` 返回值 |
| **节点重新执行** | 从节点**开头**重新执行，不是从 interrupt 行恢复 |
| **JSON 可序列化** | resume 值必须可序列化 |

## 常见模式

### 1. 审批/拒绝工作流

在关键操作前暂停请求审批：

```python
from typing import Literal
from langgraph.types import interrupt, Command

def approval_node(state: State) -> Command[Literal["proceed", "cancel"]]:
    # 暂停执行，载荷显示在 result["__interrupt__"]
    is_approved = interrupt({
        "question": "Do you want to proceed with this action?",
        "details": state["action_details"]
    })
    
    # 根据响应路由
    if is_approved:
        return Command(goto="proceed")
    else:
        return Command(goto="cancel")
```

恢复时：
```python
# 批准
graph.invoke(Command(resume=True), config=config)

# 拒绝
graph.invoke(Command(resume=False), config=config)
```

### 2. 审核和编辑状态

让人工审核并修改 LLM 输出：

```python
from langgraph.types import interrupt

def review_node(state: State):
    # 暂停并展示内容供审核
    edited_content = interrupt({
        "instruction": "Review and edit this content",
        "content": state["generated_text"]
    })
    
    # 使用编辑后的值更新状态
    return {"generated_text": edited_content}
```

恢复时提供编辑后的内容：
```python
graph.invoke(
    Command(resume="The edited and improved text"),
    config=config
)
```

### 3. 工具中的中断

在工具函数内部使用中断，实现工具调用前的审批：

```python
from langchain.tools import tool
from langgraph.types import interrupt

@tool
def send_email(to: str, subject: str, body: str):
    """Send an email to a recipient."""
    # 发送前暂停请求审批
    response = interrupt({
        "action": "send_email",
        "to": to,
        "subject": subject,
        "body": body,
        "message": "Approve sending this email?"
    })
    
    if response.get("action") == "approve":
        # 恢复值可以覆盖原始参数
        final_to = response.get("to", to)
        final_subject = response.get("subject", subject)
        final_body = response.get("body", body)
        return f"Email sent to {final_to} with subject '{final_subject}'"
    
    return "Email cancelled by user"
```

恢复时可以修改参数：
```python
graph.invoke(
    Command(resume={"action": "approve", "subject": "Updated subject"}),
    config=config
)
```

### 4. 验证人工输入

使用循环验证输入，无效时重新请求：

```python
from langgraph.types import interrupt

def get_age_node(state: State):
    prompt = "What is your age?"
    
    while True:
        answer = interrupt(prompt)
        
        # 验证输入
        if isinstance(answer, int) and answer > 0:
            break  # 有效输入，继续
        else:
            # 无效输入，更新提示重新请求
            prompt = f"'{answer}' is not a valid age. Please enter a positive number."
    
    return {"age": answer}
```

## 中断规则

### ❌ 不要用 try/except 包裹 interrupt

`interrupt()` 通过抛出特殊异常来暂停执行，try/except 会捕获它：

```python
# ❌ 错误：裸 try/except 会捕获中断异常
def node_a(state: State):
    try:
        interrupt("What's your name?")
    except Exception as e:
        print(e)
    return state

# ✅ 正确：分离 interrupt 和错误处理
def node_a(state: State):
    interrupt("What's your name?")
    try:
        fetch_data()  # 可能失败
    except Exception as e:
        print(e)
    return state

# ✅ 正确：捕获特定异常类型
def node_a(state: State):
    try:
        name = interrupt("What's your name?")
        fetch_data()
    except NetworkException as e:  # 不会捕获中断异常
        print(e)
    return state
```

### ❌ 不要重新排序 interrupt 调用

多个 interrupt 按**索引顺序**匹配恢复值：

```python
# ✅ 正确：interrupt 调用顺序一致
def node_a(state: State):
    name = interrupt("What's your name?")
    age = interrupt("What's your age?")
    city = interrupt("What's your city?")
    return {"name": name, "age": age, "city": city}

# ❌ 错误：条件跳过 interrupt 会导致索引不匹配
def node_a(state: State):
    name = interrupt("What's your name?")
    if state.get("needs_age"):  # 可能跳过
        age = interrupt("What's your age?")
    city = interrupt("What's your city?")
    return {"name": name, "city": city}

# ❌ 错误：非确定性循环中的 interrupt
def node_a(state: State):
    results = []
    for item in state.get("dynamic_list", []):  # 列表可能变化
        result = interrupt(f"Approve {item}?")
        results.append(result)
    return {"results": results}
```

### ❌ 不要传递复杂值给 interrupt

只使用 JSON 可序列化的简单类型：

```python
# ✅ 正确：简单类型
name = interrupt("What's your name?")
count = interrupt(42)
approved = interrupt(True)

# ✅ 正确：简单值的字典
response = interrupt({
    "question": "Enter user details",
    "fields": ["name", "email", "age"],
    "current_values": state.get("user", {})
})

# ❌ 错误：函数不可序列化
response = interrupt({
    "question": "What's your name?",
    "validator": validate_input  # 函数无法序列化
})

# ❌ 错误：类实例不可序列化
response = interrupt({
    "question": "Enter data",
    "processor": DataProcessor(config)  # 实例无法序列化
})
```

### ❌ interrupt 前的副作用必须幂等

节点恢复时从**开头**重新执行，interrupt 前的代码会再次运行：

```python
# ✅ 正确：使用幂等操作（upsert）
def node_a(state: State):
    db.upsert_user(user_id=state["user_id"], status="pending_approval")
    approved = interrupt("Approve this change?")
    return {"approved": approved}

# ✅ 正确：副作用放在 interrupt 之后
def node_a(state: State):
    approved = interrupt("Approve this change?")
    if approved:
        db.create_audit_log(user_id=state["user_id"], action="approved")
    return {"approved": approved}

# ✅ 正确：副作用分离到单独节点
def approval_node(state: State):
    approved = interrupt("Approve this change?")
    return {"approved": approved}

def notification_node(state: State):
    if state.approved:
        send_notification(user_id=state["user_id"], status="approved")
    return state

# ❌ 错误：非幂等操作在 interrupt 前
def node_a(state: State):
    audit_id = db.create_audit_log({  # 每次恢复都会创建新记录！
        "user_id": state["user_id"],
        "action": "pending_approval"
    })
    approved = interrupt("Approve this change?")
    return {"approved": approved}
```

## 子图中的中断

在子图中使用 interrupt 时：
- **父图**：从调用子图的节点**开头**恢复
- **子图**：从 interrupt 所在节点**开头**恢复

```python
def node_in_parent_graph(state: State):
    some_code()  # <-- 恢复时会重新执行
    subgraph_result = subgraph.invoke(some_input)
    # ...

def node_in_subgraph(state: State):
    some_other_code()  # <-- 恢复时也会重新执行
    result = interrupt("What's your name?")
    # ...
```

## 静态断点（调试用）

使用 `interrupt_before` 和 `interrupt_after` 设置静态断点，用于调试：

```python
# 编译时设置
graph = builder.compile(
    interrupt_before=["node_a"],      # 节点执行前暂停
    interrupt_after=["node_b", "node_c"],  # 节点执行后暂停
    checkpointer=checkpointer,
)

config = {"configurable": {"thread_id": "some_thread"}}

# 运行到断点
graph.invoke(inputs, config=config)

# 恢复执行（传入 None）
graph.invoke(None, config=config)
```

也可以在运行时设置：
```python
graph.invoke(
    inputs,
    interrupt_before=["node_a"],
    interrupt_after=["node_b"],
    config=config,
)
```

> **注意**：静态断点**不推荐**用于人机协作工作流，应使用 `interrupt()` 函数。

### 使用 LangGraph Studio

可以在 LangGraph Studio UI 中设置静态断点，并检查执行过程中的图状态：

![Static Interrupt](fig/static-interrupt.avif)

## 规则速查表

| 规则 | ✅ 正确 | ❌ 错误 |
|------|--------|--------|
| 异常处理 | 捕获特定异常类型 | 裸 try/except 包裹 interrupt |
| 调用顺序 | 保持 interrupt 顺序一致 | 条件跳过或非确定性循环 |
| 载荷类型 | JSON 可序列化的简单值 | 函数、类实例等复杂对象 |
| 副作用 | 幂等操作或放在 interrupt 后 | 非幂等操作在 interrupt 前 |

## 要点总结

- **interrupt()**：动态暂停点，可放在代码任意位置
- **Command(resume=...)**：恢复执行并传入响应值
- **节点重执行**：恢复时从节点开头重新执行，不是从 interrupt 行
- **常见模式**：审批工作流、审核编辑、工具中断、输入验证
- **关键规则**：不要 try/except 包裹、保持顺序、简单载荷、幂等副作用


