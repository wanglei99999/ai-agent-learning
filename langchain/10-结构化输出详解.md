# 结构化输出详解

结构化输出（Structured Output）让 Agent 以特定、可预测的格式返回数据。不再需要解析自然语言响应，而是直接获取 JSON 对象、Pydantic 模型或 dataclass 形式的结构化数据。

## 为什么需要结构化输出？

```python
# 没有结构化输出
response = "用户名是张三，邮箱是 zhangsan@example.com，电话是 13800138000"
# 需要自己解析字符串，容易出错

# 有结构化输出
response = ContactInfo(name="张三", email="zhangsan@example.com", phone="13800138000")
# 直接使用对象属性，类型安全
```

## 基本用法

使用 `response_format` 参数指定输出格式：

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent

class ContactInfo(BaseModel):
    """联系人信息"""
    name: str = Field(description="姓名")
    email: str = Field(description="邮箱地址")
    phone: str = Field(description="电话号码")

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo  # 指定输出格式
)

result = agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "提取联系信息: 张三, zhangsan@example.com, 13800138000"
    }]
})

print(result["structured_response"])
# ContactInfo(name='张三', email='zhangsan@example.com', phone='13800138000')
```

结构化响应存储在 `structured_response` 键中。

## 两种策略

| 策略 | 说明 | 适用场景 |
|------|------|----------|
| `ProviderStrategy` | 使用模型提供商的原生结构化输出 | OpenAI、Anthropic、xAI 等支持的模型 |
| `ToolStrategy` | 使用工具调用实现结构化输出 | 所有支持工具调用的模型 |

当直接传递 schema 类型时，LangChain 会自动选择：
- 如果模型支持原生结构化输出 → `ProviderStrategy`
- 否则 → `ToolStrategy`

## Provider 策略

某些模型提供商（如 OpenAI、Anthropic、Gemini）原生支持结构化输出，这是最可靠的方法。

```python
from langchain.agents.structured_output import ProviderStrategy

class ProviderStrategy:
    schema: type        # 输出格式的 schema
    strict: bool = None # 是否启用严格模式（部分提供商支持）
```

### 支持的 Schema 类型

#### Pydantic 模型（推荐）

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent

class ContactInfo(BaseModel):
    """联系人信息"""
    name: str = Field(description="姓名")
    email: str = Field(description="邮箱地址")
    phone: str = Field(description="电话号码")

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo  # 自动选择 ProviderStrategy
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "提取: 张三, zhangsan@example.com, 13800138000"}]
})

print(result["structured_response"])
# ContactInfo(name='张三', email='zhangsan@example.com', phone='13800138000')
print(result["structured_response"].name)  # 张三 - 可以直接访问属性
```

返回 Pydantic 实例，有类型提示和自动验证。

#### Dataclass

```python
from dataclasses import dataclass
from langchain.agents import create_agent

@dataclass
class ContactInfo:
    """联系人信息"""
    name: str   # 姓名
    email: str  # 邮箱地址
    phone: str  # 电话号码

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "提取: 张三, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': '张三', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

返回字典。

#### TypedDict

```python
from typing_extensions import TypedDict
from langchain.agents import create_agent

class ContactInfo(TypedDict):
    """联系人信息"""
    name: str   # 姓名
    email: str  # 邮箱地址
    phone: str  # 电话号码

agent = create_agent(
    model="gpt-4o",
    response_format=ContactInfo
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "提取: 张三, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': '张三', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

返回字典。

#### JSON Schema

```python
from langchain.agents import create_agent
from langchain.agents.structured_output import ProviderStrategy

contact_info_schema = {
    "type": "object",
    "description": "联系人信息",
    "properties": {
        "name": {"type": "string", "description": "姓名"},
        "email": {"type": "string", "description": "邮箱地址"},
        "phone": {"type": "string", "description": "电话号码"}
    },
    "required": ["name", "email", "phone"]
}

agent = create_agent(
    model="gpt-4o",
    response_format=ProviderStrategy(contact_info_schema)
)

result = agent.invoke({
    "messages": [{"role": "user", "content": "提取: 张三, zhangsan@example.com, 13800138000"}]
})

result["structured_response"]
# {'name': '张三', 'email': 'zhangsan@example.com', 'phone': '13800138000'}
```

返回字典。

## Tool 策略

对于不支持原生结构化输出的模型，LangChain 使用工具调用来实现。这适用于所有支持工具调用的模型。

```python
from langchain.agents.structured_output import ToolStrategy

class ToolStrategy:
    schema: type                    # 输出格式的 schema
    tool_message_content: str = None  # 自定义工具消息内容
    handle_errors: bool | str | ... = True  # 错误处理策略
```

### 基本用法

```python
from pydantic import BaseModel, Field
from typing import Literal
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductReview(BaseModel):
    """产品评价分析"""
    rating: int | None = Field(description="评分 1-5", ge=1, le=5)
    sentiment: Literal["positive", "negative"] = Field(description="情感倾向")
    key_points: list[str] = Field(description="关键点，小写，1-3 个词")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(ProductReview)
)

result = agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "分析这条评价: '很棒的产品，5 星好评。发货快，但有点贵'"
    }]
})

result["structured_response"]
# ProductReview(rating=5, sentiment='positive', key_points=['发货快', '有点贵'])
```

### Union 类型（多种输出格式）

模型会根据上下文选择最合适的 schema：

```python
from pydantic import BaseModel, Field
from typing import Literal, Union
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductReview(BaseModel):
    """产品评价"""
    rating: int | None = Field(description="评分 1-5", ge=1, le=5)
    sentiment: Literal["positive", "negative"] = Field(description="情感倾向")
    key_points: list[str] = Field(description="关键点")

class CustomerComplaint(BaseModel):
    """客户投诉"""
    issue_type: Literal["product", "service", "shipping", "billing"] = Field(description="问题类型")
    severity: Literal["low", "medium", "high"] = Field(description="严重程度")
    description: str = Field(description="问题描述")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(Union[ProductReview, CustomerComplaint])
)

# 输入评价 → 返回 ProductReview
result = agent.invoke({
    "messages": [{"role": "user", "content": "分析: '很棒的产品，5 星好评'"}]
})
# ProductReview(rating=5, sentiment='positive', key_points=['很棒'])

# 输入投诉 → 返回 CustomerComplaint
result = agent.invoke({
    "messages": [{"role": "user", "content": "分析: '发货太慢了，等了两周还没到'"}]
})
# CustomerComplaint(issue_type='shipping', severity='high', description='发货延迟两周')
```

### 自定义工具消息内容

```python
from pydantic import BaseModel, Field
from typing import Literal
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class MeetingAction(BaseModel):
    """会议待办事项"""
    task: str = Field(description="具体任务")
    assignee: str = Field(description="负责人")
    priority: Literal["low", "medium", "high"] = Field(description="优先级")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(
        schema=MeetingAction,
        tool_message_content="待办事项已记录到会议纪要！"  # 自定义消息
    )
)

agent.invoke({
    "messages": [{"role": "user", "content": "会议记录: 小王需要尽快更新项目时间线"}]
})
```

对话历史中的工具消息：
```
================================= Tool Message =================================
Name: MeetingAction
待办事项已记录到会议纪要！
```

如果不设置 `tool_message_content`，默认是：
```
================================= Tool Message =================================
Name: MeetingAction
Returning structured response: {'task': '更新项目时间线', 'assignee': '小王', 'priority': 'high'}
```

## 错误处理

模型在生成结构化输出时可能会出错。LangChain 提供智能重试机制自动处理这些错误。

### 多个结构化输出错误

当模型错误地调用多个结构化输出工具时，Agent 会提供错误反馈并提示模型重试：

```python
from pydantic import BaseModel, Field
from typing import Union
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ContactInfo(BaseModel):
    name: str = Field(description="姓名")
    email: str = Field(description="邮箱")

class EventDetails(BaseModel):
    event_name: str = Field(description="活动名称")
    date: str = Field(description="活动日期")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(Union[ContactInfo, EventDetails])  # 默认 handle_errors=True
)

agent.invoke({
    "messages": [{
        "role": "user", 
        "content": "提取信息: 张三 (zhangsan@email.com) 正在组织 3 月 15 日的技术大会"
    }]
})
```

执行流程：
```
================================ Human Message =================================
提取信息: 张三 (zhangsan@email.com) 正在组织 3 月 15 日的技术大会

================================== Ai Message ==================================
Tool Calls:
  ContactInfo (call_1)
    Args: name: 张三, email: zhangsan@email.com
  EventDetails (call_2)
    Args: event_name: 技术大会, date: 3月15日

================================= Tool Message =================================
Name: ContactInfo
Error: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) 
when only one is expected. Please fix your mistakes.

================================= Tool Message =================================
Name: EventDetails
Error: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) 
when only one is expected. Please fix your mistakes.

================================== Ai Message ==================================
Tool Calls:
  ContactInfo (call_3)
    Args: name: 张三, email: zhangsan@email.com

================================= Tool Message =================================
Name: ContactInfo
Returning structured response: {'name': '张三', 'email': 'zhangsan@email.com'}
```

### Schema 验证错误

当结构化输出不符合预期 schema 时，Agent 会提供具体的错误反馈：

```python
from pydantic import BaseModel, Field
from langchain.agents import create_agent
from langchain.agents.structured_output import ToolStrategy

class ProductRating(BaseModel):
    rating: int | None = Field(description="评分 1-5", ge=1, le=5)  # 限制 1-5
    comment: str = Field(description="评价内容")

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(ProductRating),
    system_prompt="你是一个解析产品评价的助手。不要编造任何字段或值。"
)

agent.invoke({
    "messages": [{"role": "user", "content": "解析: 超棒的产品，10/10！"}]
})
```

执行流程：
```
================================ Human Message =================================
解析: 超棒的产品，10/10！

================================== Ai Message ==================================
Tool Calls:
  ProductRating (call_1)
    Args: rating: 10, comment: 超棒的产品

================================= Tool Message =================================
Name: ProductRating
Error: Failed to parse structured output for tool 'ProductRating': 
1 validation error for ProductRating.rating
Input should be less than or equal to 5 [type=less_than_equal, input_value=10, input_type=int].
Please fix your mistakes.

================================== Ai Message ==================================
Tool Calls:
  ProductRating (call_2)
    Args: rating: 5, comment: 超棒的产品

================================= Tool Message =================================
Name: ProductRating
Returning structured response: {'rating': 5, 'comment': '超棒的产品'}
```

### 错误处理策略

`handle_errors` 参数支持多种配置：

#### 默认行为（True）

```python
ToolStrategy(schema=ProductRating)  # 默认 handle_errors=True
# 捕获所有错误，使用默认错误消息
```

#### 自定义错误消息

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors="请提供 1-5 的有效评分并包含评价内容。"
)
# 所有错误都使用这个固定消息
```

#### 只处理特定异常

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors=ValueError  # 只重试 ValueError，其他异常直接抛出
)

ToolStrategy(
    schema=ProductRating,
    handle_errors=(ValueError, TypeError)  # 只重试这两种异常
)
```

#### 自定义错误处理函数

```python
from langchain.agents.structured_output import (
    StructuredOutputValidationError,
    MultipleStructuredOutputsError
)

def custom_error_handler(error: Exception) -> str:
    if isinstance(error, StructuredOutputValidationError):
        return "格式有问题，请重试。"
    elif isinstance(error, MultipleStructuredOutputsError):
        return "返回了多个结构化输出，请选择最相关的一个。"
    else:
        return f"错误: {str(error)}"

agent = create_agent(
    model="gpt-4o",
    tools=[],
    response_format=ToolStrategy(
        schema=Union[ContactInfo, EventDetails],
        handle_errors=custom_error_handler
    )
)
```

#### 禁用错误处理

```python
ToolStrategy(
    schema=ProductRating,
    handle_errors=False  # 所有错误直接抛出
)
```

## 两种策略对比

| 特性 | ProviderStrategy | ToolStrategy |
|------|------------------|--------------|
| 可靠性 | 高（提供商强制执行 schema） | 中（依赖模型遵循指令） |
| 兼容性 | 仅支持特定提供商 | 所有支持工具调用的模型 |
| 错误处理 | 提供商处理 | 内置重试机制 |
| Union 类型 | 部分支持 | 完全支持 |
| 自定义消息 | 不支持 | 支持 |

## Schema 类型对比

| 类型 | 返回值 | 运行时验证 | 适用场景 |
|------|--------|------------|----------|
| Pydantic | 对象 | ✅ 有 | 需要验证、复杂嵌套结构 |
| Dataclass | 字典 | ❌ 无 | 简单场景 |
| TypedDict | 字典 | ❌ 无 | 轻量级、类型提示 |
| JSON Schema | 字典 | ❌ 无 | 跨语言、最大控制 |

### 本质：都是 JSON Schema

不管你用哪种类型定义，LangChain 内部都会转成 JSON Schema 发给模型：

```
你定义的类型                    发给模型的                模型返回的        最终给你的
     ↓                            ↓                        ↓                ↓
Pydantic/Dataclass/TypedDict → JSON Schema → 模型生成 JSON → 解析/格式化
```

**具体过程：**

```python
# 你写的
class ContactInfo(BaseModel):
    name: str = Field(description="姓名")
    email: str = Field(description="邮箱")

# LangChain 内部转成 JSON Schema 发给模型
{
    "type": "object",
    "properties": {
        "name": {"type": "string", "description": "姓名"},
        "email": {"type": "string", "description": "邮箱"}
    },
    "required": ["name", "email"]
}

# 模型返回 JSON
{"name": "张三", "email": "zhangsan@example.com"}

# LangChain 格式化成你要的类型
# Pydantic → ContactInfo(name='张三', email='zhangsan@example.com')
# 其他类型 → {'name': '张三', 'email': 'zhangsan@example.com'}
```

**区别只在最后一步：**

| 类型 | 最后一步做了什么 |
|------|-----------------|
| Pydantic | JSON → Pydantic 对象（有验证） |
| Dataclass | JSON → dict（无验证） |
| TypedDict | JSON → dict（无验证） |
| JSON Schema | JSON → dict（无验证） |

Pydantic 多做了一步验证和对象转换，这就是它"更强"的原因。

### TypedDict vs Dataclass

在 LangChain 结构化输出场景下，它们效果一样（都返回字典）。但在 Python 本身有区别：

| 特性 | TypedDict | Dataclass |
|------|-----------|-----------|
| 本质 | 类型提示（给字典加类型） | 真正的类 |
| 运行时 | 就是普通 dict | 是类的实例 |
| 实例化 | 不能 `TypedDict()` 创建 | 可以 `Dataclass()` 创建 |

```python
from typing_extensions import TypedDict
from dataclasses import dataclass

# TypedDict - 只是类型提示，运行时就是 dict
class PersonTD(TypedDict):
    name: str
    age: int

p1 = {"name": "张三", "age": 25}  # 直接用字典
# PersonTD(name="张三", age=25)  # ❌ 不能这样创建

# Dataclass - 真正的类
@dataclass
class PersonDC:
    name: str
    age: int

p2 = PersonDC(name="张三", age=25)  # ✅ 可以实例化
p2.name  # 张三 ← 用 .属性 访问
```

**为什么在 LangChain 里效果一样？** 因为 LangChain 内部都把它们转成 JSON Schema，然后把模型返回的 JSON 解析成字典返回给你。

### 怎么选？

| 场景 | 推荐 |
|------|------|
| 需要字段验证（范围、格式等） | Pydantic |
| 需要对象式访问 `.name` | Pydantic |
| 简单场景，不需要验证 | TypedDict 或 Dataclass |
| 跨语言、动态生成 schema | JSON Schema |

**大多数情况可以用 Pydantic**，功能最全，验证最严格。

## 总结

| 概念 | 说明 |
|------|------|
| `response_format` | 指定 Agent 的输出格式 |
| `structured_response` | 结构化响应存储的键 |
| `ProviderStrategy` | 使用提供商原生结构化输出 |
| `ToolStrategy` | 使用工具调用实现结构化输出 |
| `handle_errors` | 错误处理策略 |
| `tool_message_content` | 自定义工具消息内容 |
| `Union` 类型 | 支持多种输出格式，模型自动选择 |
